# HackerRanker SQL problems

### 01. Revising the Select Query I
```SQL
SELECT *
FROM CITY
WHERE POPULATION > 100000
AND COUNTRYCODE = 'USA'
```

### 02. Revising the Select Query II
```SQL
SELECT NAME
FROM CITY
WHERE POPULATION > 120000
AND COUNTRYCODE = 'USA'
```

### 03. Select All
```SQL
SELECT *
FROM CITY
```

### 04. Select By ID
```SQL
SELECT *
FROM CITY
WHERE ID = 1661
```

### 05. Japanese Cities' Attributes
```SQL
SELECT *
FROM CITY
WHERE COUNTRYCODE = 'JPN'
```

### 06. Japanese Cities' Names
```SQL
SELECT NAME
FROM CITY
WHERE COUNTRYCODE = 'JPN'
```

### 07. Weather Observation Station 1
```SQL
SELECT
    CITY,
    STATE
FROM STATION
```

### 08. Weather Observation Station 3
```SQL
SELECT
    DISTINCT CITY
FROM STATION
WHERE ID % 2 = 0
```

### 09. Weather Observation Station 4
```SQL
SELECT
    COUNT(CITY) - COUNT(DISTINCT CITY)
FROM STATION
```

### 10. Weather Observation Station 5
* 方法 1. 用 union 時，如果 query 中有 `order by`, `limit` 等關鍵字，就要先用括號把 query 刮起來
* `Union` 結合的兩個 query 要有相同的欄位
```SQL
(
SELECT
    MIN(CITY) AS CITY,
    LENGTH(CITY) AS LEN
FROM STATION
GROUP BY LENGTH(CITY)
ORDER BY 2, 1
LIMIT 1
)
UNION
(
SELECT
    MAX(CITY) AS CITY,
    LENGTH(CITY) AS LEN
FROM STATION
GROUP BY LENGTH(CITY)
ORDER BY 2 DESC, 1
LIMIT 1
)
```
```SQL
(
    SELECT
        CITY,
        LENGTH(CITY)
    FROM STATION
    WHERE LENGTH(CITY) = (
        SELECT
            MIN(LENGTH(CITY))
        FROM STATION
    )
    ORDER BY 1
    LIMIT 1
)
UNION
(
    SELECT
        CITY,
        LENGTH(CITY)
    FROM STATION
    WHERE LENGTH(CITY) = (
        SELECT
            MAX(LENGTH(CITY))
        FROM STATION
    )
    ORDER BY 1
    LIMIT 1
)
```
* 方法 2. 分別寫兩個 query 用分號區隔開來
```SQL
SELECT
    CITY,
    MIN(LENGTH(CITY))
FROM STATION
GROUP BY 1
HAVING LENGTH(CITY) = (
    SELECT
        MIN(LENGTH(CITY))
    FROM STATION
)
ORDER BY 1
LIMIT 1;
SELECT
    CITY,
    MAX(LENGTH(CITY))
FROM STATION
GROUP BY 1
HAVING LENGTH(CITY) = (
    SELECT
        MAX(LENGTH(CITY))
    FROM STATION
)
ORDER BY 1
LIMIT 1;
```

### 11. Weather Observation Station 6
* 方法 1.
```SQL
SELECT CITY
FROM STATION
WHERE CITY LIKE 'A%'
OR CITY LIKE 'E%'
OR CITY LIKE 'I%'
OR CITY LIKE 'O%'
OR CITY LIKE 'U%'
```
* 方法 2.
```SQL
SELECT
    CITY
FROM STATION
WHERE LEFT(CITY, 1) IN ('A', 'E', 'I', 'O', 'U')
```

### 12. Weather Observation Station 7
* 方法 1.
```SQL
SELECT DISTINCT CITY
FROM STATION
WHERE CITY LIKE '%A'
OR CITY LIKE '%E'
OR CITY LIKE '%I'
OR CITY LIKE '%O'
OR CITY LIKE '%U'
```
* 方法 2.
```SQL
SELECT
    DISTINCT CITY
FROM STATION
WHERE RIGHT(CITY, 1) IN ('A', 'E', 'I', 'O', 'U')
```

### 13. Weather Observation Station 8
```SQL
SELECT
    DISTINCT CITY
FROM STATION
WHERE LEFT(CITY, 1) IN ('A', 'E', 'I', 'O', 'U')
AND RIGHT(CITY, 1) IN ('A', 'E', 'I', 'O', 'U')
```

### 14. Weather Observation Station 9
```SQL
SELECT
    DISTINCT CITY
FROM STATION
WHERE LEFT(CITY, 1) NOT IN ('A', 'E', 'I', 'O', 'U')
```

### 15. Weather Observation Station 10
```SQL
SELECT
    DISTINCT CITY
FROM STATION
WHERE RIGHT(CITY, 1) NOT IN ('A', 'E', 'I', 'O', 'U')
```

### 16. Weather Observation Station 11
```SQL
SELECT
    DISTINCT CITY
FROM STATION
WHERE LEFT(CITY, 1) NOT IN ('A', 'E', 'I', 'O', 'U')
OR RIGHT(CITY, 1) NOT IN ('A', 'E', 'I', 'O', 'U')
```

### 17. Weather Observation Station 12
```SQL
SELECT
    DISTINCT CITY
FROM STATION
WHERE LEFT(CITY, 1) NOT IN ('A', 'E', 'I', 'O', 'U')
AND RIGHT(CITY, 1) NOT IN ('A', 'E', 'I', 'O', 'U')
```

### 18. Higher Than 75 Marks
```SQL
SELECT
    NAME
FROM STUDENTS S
WHERE MARKS > 75
ORDER BY RIGHT(NAME, 3), ID
```

### 19. Employee Names
```SQL
SELECT
    NAME
FROM EMPLOYEE
ORDER BY 1
```

### 20. Employee Salaries
```SQL
SELECT
    NAME
FROM EMPLOYEE
WHERE SALARY > 2000
AND MONTHS < 10
ORDER BY EMPLOYEE_ID
```

### 21. Type of Triangle
* 注意用"兩邊之和大於第三邊"先判斷是不是三角形
```SQL
SELECT
    CASE
        WHEN A + B <= C OR B + C <= A OR C + A <= B THEN 'Not A Triangle'
        WHEN A = B AND A = C THEN 'Equilateral'
        WHEN A = B OR A = C OR B = C THEN 'Isosceles'
        ELSE 'Scalene'
    END AS TRIANGLE
FROM TRIANGLES
```

### 22. The PADS
* `CONCAT()` 不會產生空白，需要空白要自己加入
```SQL
SELECT
    CONCAT(NAME, '(', LEFT(OCCUPATION, 1), ')')
FROM OCCUPATIONS
ORDER BY NAME;
SELECT
    CONCAT('There are a total of ', COUNT(*), ' ', LOWER(OCCUPATION), 's.')
FROM OCCUPATIONS
GROUP BY OCCUPATION
ORDER BY COUNT(*) , OCCUPATION;
```

### 23. Occupations (難)
* 如果只用 case 述句，那會形成一個有很多 NULL 的表格，每一個 row 只有一個欄位不是 NULL，這不是答案要的結果
* 要利用到 `ROW_NUMBER()` 先建立編號，然後用 `GROUP BY 編號` 時，相同編號的就會在同一 row
* `MAX()` 在這邊的功用只是因為要使用 `GROUP BY 編號` 需要一個 aggregation functions，所以用 `MIN()` 也是可以的
* 要記得 subquery 都要有名字
* 方法 1. 用 `MAX()`
```SQL
SELECT
    MAX(CASE WHEN SUB.OCCUPATION = 'Doctor' THEN SUB.NAME END) AS DOCTOR,
    MAX(CASE WHEN SUB.OCCUPATION = 'Professor' THEN SUB.NAME END) AS PROFESSOR,
    MAX(CASE WHEN SUB.OCCUPATION = 'Singer' THEN SUB.NAME END) AS SINGER,
    MAX(CASE WHEN SUB.OCCUPATION = 'Actor' THEN SUB.NAME END) AS ACTOR
FROM (
    SELECT
        ROW_NUMBER() OVER (PARTITION BY OCCUPATION ORDER BY NAME) AS ID,
        NAME,
        OCCUPATION
    FROM OCCUPATIONS
) SUB
GROUP BY SUB.ID
```
* 方法 2. 用 `MIN()`
```SQL
SELECT
    MIN(CASE WHEN SUB.OCCUPATION = 'Doctor' THEN SUB.NAME ELSE NULL END) AS 'Doctor',
    MIN(CASE WHEN SUB.OCCUPATION = 'Professor' THEN SUB.NAME ELSE NULL END) AS 'Professor',
    MIN(CASE WHEN SUB.OCCUPATION = 'Singer' THEN SUB.NAME ELSE NULL END) AS 'Singer',
    MIN(CASE WHEN SUB.OCCUPATION = 'Actor' THEN SUB.NAME ELSE NULL END) AS 'Actor'
FROM (
    SELECT
        ROW_NUMBER() OVER (PARTITION BY OCCUPATION ORDER BY NAME) AS 'ROW_NUMBER',
        NAME,
        OCCUPATION
    FROM OCCUPATIONS
) SUB
GROUP BY SUB.ROW_NUMBER
```

### 24. Binary Tree Nodes
* 如果沒有父節點，那就是 root
* 如果一個節點是別人的父節點，那就會屬於 inner
* 如果不是別的節點的父節點，那就是 leaf
```SQL
SELECT
    N,
    IF(P IS NULL, 'Root', IF(N IN (SELECT DISTINCT P FROM BST), 'Inner', 'Leaf'))
FROM BST
ORDER BY N
```
```SQL
SELECT
    N,
    CASE
        WHEN P IS NULL THEN 'Root'
        WHEN N IN (SELECT DISTINCT P FROM BST) AND N IS NOT NULL THEN 'Inner'
        ELSE 'Leaf'
    END AS 'TYPE'
FROM BST
ORDER BY 1
```

### 25. New Companies
* 方法 1.
```SQL
SELECT
    C.COMPANY_CODE,
    C.FOUNDER,
    L.LCOUNT,
    S.SCOUNT,
    M.MCOUNT,
    E.ECOUNT
FROM COMPANY AS C
LEFT JOIN (
    SELECT
        COMPANY_CODE,
        COUNT(DISTINCT LEAD_MANAGER_CODE) AS LCOUNT
    FROM LEAD_MANAGER
    GROUP BY COMPANY_CODE
) AS L
ON C.COMPANY_CODE = L.COMPANY_CODE
LEFT JOIN (
    SELECT
        COMPANY_CODE,
        COUNT(DISTINCT SENIOR_MANAGER_CODE) AS SCOUNT
    FROM SENIOR_MANAGER
    GROUP BY COMPANY_CODE
) AS S
ON C.COMPANY_CODE = S.COMPANY_CODE
LEFT JOIN (
    SELECT
        COMPANY_CODE,
        COUNT(DISTINCT MANAGER_CODE) AS MCOUNT
    FROM MANAGER
    GROUP BY COMPANY_CODE
) AS M
ON C.COMPANY_CODE = M.COMPANY_CODE
LEFT JOIN (
    SELECT
        COMPANY_CODE,
        COUNT(DISTINCT EMPLOYEE_CODE) AS ECOUNT
    FROM EMPLOYEE
    GROUP BY COMPANY_CODE
) AS E
ON C.COMPANY_CODE = E.COMPANY_CODE
ORDER BY C.COMPANY_CODE;
```
* 方法 2. employee 表格中已經有 lead_manager, senior_manager, 和 manager 的資訊了，所以只用 employee 表格就好
* 因為各階層的主管底下會有不同員工，所以主管會重複很多次，要記得取 distinct
```SQL
SELECT
    C.COMPANY_CODE,
    C.FOUNDER,
    E.NUM_LEAD,
    E.NUM_SENIOR,
    E.NUM_MANAGER,
    E.NUM_EMPLOYEE
FROM COMPANY AS C
JOIN (
    SELECT
        COMPANY_CODE,
        COUNT(DISTINCT LEAD_MANAGER_CODE) AS NUM_LEAD,
        COUNT(DISTINCT SENIOR_MANAGER_CODE) AS NUM_SENIOR,
        COUNT(DISTINCT MANAGER_CODE) AS NUM_MANAGER,
        COUNT(DISTINCT EMPLOYEE_CODE) AS NUM_EMPLOYEE
    FROM EMPLOYEE
    GROUP BY 1
    ORDER BY 1
) AS E
ON C.COMPANY_CODE = E.COMPANY_CODE
ORDER BY C.COMPANY_CODE
```

### 26. Revising Aggregations - The Count Function
```SQL
SELECT
    COUNT(NAME)
FROM CITY
WHERE POPULATION > 100000
```

### 27. Revising Aggregations - The Sum Function
```SQL
SELECT
    SUM(POPULATION)
FROM CITY
WHERE DISTRICT = 'California'
```

### 28. Revising Aggregations - Averages
```SQL
SELECT
    AVG(POPULATION)
FROM CITY
WHERE DISTRICT='California'
```

### 29. Average Population
```SQL
SELECT
    FLOOR(AVG(POPULATION))
FROM CITY
```

### 30. Japan Population
```SQL
SELECT
    SUM(POPULATION)
FROM CITY
WHERE COUNTRYCODE = 'JPN'
```

### 31. Population Density Difference
```SQL
SELECT
    MAX(POPULATION) - MIN(POPULATION)
FROM CITY
```

### 32. The Blunder
```SQL
SELECT
    CEIL(AVG(SALARY) - AVG(CAST(REPLACE(SALARY, '0', '') AS FLOAT)))
FROM EMPLOYEES
```
```SQL
SELECT
    CEIL(AVG(Salary) - AVG(REPLACE(Salary, '0', '')))
FROM EMPLOYEES
```

### 33. Top Earners
```SQL
SELECT
    MONTHS * SALARY, COUNT(*)
FROM EMPLOYEE
    WHERE MONTHS * SALARY = (
    SELECT
        MAX(MONTHS * SALARY)
    FROM EMPLOYEE
)
GROUP BY MONTHS * SALARY
```

### 34. Weather Observation Station 2
```SQL
SELECT
    ROUND(SUM(LAT_N), 2),
    ROUND(SUM(LONG_W), 2)
FROM STATION
```

### 35. Weather Observation Station 13
```SQL
SELECT ROUND(SUM(LAT_N), 4)
FROM STATION
WHERE LAT_N > 38.7880 AND LAT_N < 137.2345
```
```SQL
SELECT
    ROUND(SUM(SUB.LAT_N), 4)
FROM (
    SELECT
        ID,
        LAT_N
    FROM STATION
    WHERE LAT_N BETWEEN 38.7880 AND 137.2345
) SUB

```

### 36. Weather Observation Station 14
```SQL
SELECT
    ROUND(MAX(LAT_N), 4)
FROM STATION
WHERE LAT_N < 137.2345
```

### 37. Weather Observation Station 15
```SQL
SELECT
    ROUND(LONG_W, 4)
FROM STATION
WHERE LAT_N = (
    SELECT
        MAX(LAT_N)
    FROM STATION
    WHERE LAT_N < 137.2345
) 
```

### 38. Weather Observation Station 16
```SQL
SELECT ROUND(LAT_N, 4)
FROM STATION
WHERE LAT_N = (
    SELECT MIN(LAT_N)
    FROM STATION
    WHERE LAT_N > 38.7780
)
```
```SQL
SELECT
    ROUND(MIN(LAT_N), 4)
FROM STATION
WHERE LAT_N > 38.7780
```

### 39. Weather Observation Station 17
```SQL
SELECT
    ROUND(LONG_W, 4)
FROM STATION
WHERE LAT_N = (
    SELECT
        MIN(LAT_N)
    FROM STATION
    WHERE LAT_N > 38.7780
)
```

### 40. Weather Observation Station 18
```SQL
-- Manhattan distance = |x1 - x2| + |y1 - y2|
SELECT
    ROUND(ABS(MIN(LAT_N) - MAX(LAT_N)) + ABS(MIN(LONG_W) - MAX(LONG_W)), 4)
FROM STATION
```

### 41. Weather Observation Station 19
```SQL
-- Euclidean distance = sqrt( (x1 - x2)^2 + (y1 - y2)^2 )
SELECT
    ROUND(SQRT(POWER(MIN(LAT_N) - MAX(LAT_N), 2) + POWER(MIN(LONG_W) - MAX(LONG_W), 2)), 4)
FROM STATION
```

### 42. Weather Observation Station 20
* 方法 1. 只要知道 `PERCENT_RANK()` 那這題就能解
```SQL
SELECT ROUND(SUB.LAT_N, 4)
FROM (
    SELECT
        PERCENT_RANK() OVER (ORDER BY LAT_N) AS PCT,
        LAT_N
    FROM STATION
) SUB
WHERE PCT = 0.5
```
* 方法 2. 奇數 row: median = 正中間那個，偶數 row: median = 正中間兩個相加除以二
* 這一題一定是奇數 row，如果是偶數會選出兩個 row 就無法指定哪個是 median
```SQL
SELECT
    ROUND(SUB.LAT_N, 4)
FROM (
    SELECT
        LAT_N,
        ROW_NUMBER() OVER (ORDER BY LAT_N) AS 'ROW_NUMBER'
    FROM STATION
) SUB
WHERE SUB.ROW_NUMBER = (
    SELECT
        CEIL(COUNT(LAT_N) / 2)
    FROM STATION
)
```

### 43. Population Census
```SQL
SELECT
    SUM(CITY.POPULATION)
FROM CITY, COUNTRY
WHERE CITY.COUNTRYCODE = COUNTRY.CODE
AND CONTINENT = 'Asia'
```
```SQL
SELECT
    SUM(CITY.POPULATION)
FROM CITY
JOIN COUNTRY
ON CITY.COUNTRYCODE = COUNTRY.CODE
WHERE COUNTRY.CONTINENT = 'Asia'
```

### 44. African Cities
```SQL
SELECT CITY.NAME
FROM CITY, COUNTRY
WHERE CITY.COUNTRYCODE = COUNTRY.CODE
AND COUNTRY.CONTINENT = 'Africa'
```
```SQL
SELECT
    CITY.NAME
FROM CITY
JOIN COUNTRY
ON CITY.COUNTRYCODE = COUNTRY.CODE
WHERE COUNTRY.CONTINENT = 'Africa'
```

### 45. Average Population of Each Continent
```SQL
SELECT
    COUNTRY.CONTINENT,
    FLOOR(AVG(CITY.POPULATION))
FROM CITY, COUNTRY
WHERE CITY.COUNTRYCODE = COUNTRY.CODE
GROUP BY 1
```
```SQL
SELECT
    COUNTRY.CONTINENT,
    FLOOR(AVG(CITY.POPULATION))
FROM CITY
JOIN COUNTRY
ON CITY.COUNTRYCODE = COUNTRY.CODE
GROUP BY 1
```

### 46. The Report
```SQL
SELECT
    CASE
        WHEN G.GRADE >= 8 THEN S.NAME
        ELSE 'NULL'
    END AS NAME,
    G.GRADE,
    S.MARKS
FROM STUDENTS AS S
LEFT JOIN GRADES AS G
ON S.MARKS BETWEEN G.MIN_MARK AND MAX_MARK
ORDER BY G.GRADE DESC, NAME
```
```SQL
SELECT
    CASE
        WHEN GRADES.GRADE < 8 THEN NULL
        ELSE STUDENTS.NAME
    END,
    GRADES.GRADE,
    STUDENTS.MARKS
FROM STUDENTS
JOIN GRADES
ON STUDENTS.MARKS BETWEEN GRADES.MIN_MARK AND GRADES.MAX_MARK
ORDER BY GRADES.GRADE DESC, NAME, MARKS
```

### 47. Top Competitors (有點難)
* 方法 1. 注意可以用 `HAVING`
```SQL
SELECT
    H.HACKER_ID,
    H.NAME
FROM HACKERS AS H
JOIN SUBMISSIONS AS S
ON H.HACKER_ID = S.HACKER_ID
JOIN CHALLENGES AS C
ON S.CHALLENGE_ID = C.CHALLENGE_ID
JOIN DIFFICULTY AS D
ON C.DIFFICULTY_LEVEL = D.DIFFICULTY_LEVEL
WHERE S.SCORE = D.SCORE
GROUP BY 1, 2
HAVING COUNT(H.HACKER_ID) > 1
ORDER BY COUNT(H.HACKER_ID) DESC, H.HACKER_ID
```
* 方法 2. challenges 表格重要的只有 challenge_id 和 difficulty_level (因為要得到每個 challenge_id 的總分)
```SQL
SELECT
    H.HACKER_ID,
    H.NAME
FROM (
    SELECT
        S.HACKER_ID,
        COUNT(S.CHALLENGE_ID) AS CNT
    FROM SUBMISSIONS AS S
    LEFT JOIN (
        SELECT
            C.CHALLENGE_ID,
            D.SCORE
        FROM CHALLENGES AS C
        JOIN DIFFICULTY AS D
        ON C.DIFFICULTY_LEVEL = D.DIFFICULTY_LEVEL
    ) AS SUB1
    ON S.CHALLENGE_ID = SUB1.SUB1.CHALLENGE_ID
    WHERE S.SCORE = SUB1.SCORE
    GROUP BY 1
) SUB2
JOIN HACKERS AS H
ON SUB2.HACKER_ID = H.HACKER_ID
WHERE SUB2.CNT > 1
ORDER BY SUB2.CNT DESC, H.HACKER_ID
```

### 48. Ollivander's Inventory (難)
* 要注意，相同 (power, age) 時要選擇最小的價格的魔杖
```SQL
SELECT
    W.ID,
    WP.AGE,
    W.COINS_NEEDED,
    W.POWER
FROM WANDS AS W
JOIN WANDS_PROPERTY AS WP
ON W.CODE = WP.CODE
WHERE WP.IS_EVIL = 0
AND (W.POWER, WP.AGE, W.COINS_NEEDED) IN (
    SELECT
        W.POWER,
        WP.AGE,
        MIN(W.COINS_NEEDED)
    FROM WANDS AS W
    JOIN WANDS_PROPERTY AS WP
    ON W.CODE = WP.CODE
    GROUP BY W.POWER, WP.AGE
)
ORDER BY W.POWER DESC, WP.AGE DESC
```

### 49. Challenges (難)
* 方法 1.
```SQL
WITH TEMP1 AS (
    SELECT
        H.HACKER_ID,
        H.NAME,
        COUNT(C.CHALLENGE_ID) AS TOTAL_CHALLENGES
    FROM HACKERS AS H
    JOIN CHALLENGES AS C
    ON H.HACKER_ID = C.HACKER_ID
    GROUP BY 1, 2
),
TEMP2 AS (
    SELECT
        HACKER_ID,
        NAME,
        TOTAL_CHALLENGES,
        COUNT(TOTAL_CHALLENGES) OVER (PARTITION BY TOTAL_CHALLENGES) AS CNT
    FROM TEMP1
)
SELECT
    HACKER_ID,
    NAME,
    TOTAL_CHALLENGES
FROM TEMP2
WHERE TOTAL_CHALLENGES = (SELECT MAX(TOTAL_CHALLENGES) FROM TEMP1)
OR CNT = 1
ORDER BY 3 DESC, 1
```
```SQL
WITH TEMP1 AS (
    SELECT
        HACKER_ID,
        COUNT(CHALLENGE_ID) AS CNT
    FROM CHALLENGES
    GROUP BY 1
),
TEMP2 AS (
    SELECT
        HACKER_ID,
        CNT,
        COUNT(CNT) OVER (PARTITION BY CNT) AS DUPLICATES
    FROM TEMP1
)
SELECT
    H.HACKER_ID,
    H.NAME,
    C.CNT
FROM HACKERS H
JOIN TEMP2 AS C
ON H.HACKER_ID = C.HACKER_ID
WHERE CNT = (
    SELECT
        MAX(CNT)
    FROM TEMP1
)
OR DUPLICATES = 1
ORDER BY 3 DESC, 1
```
* 方法 2.
```SQL
SELECT
    HACKER_ID,
    NAME,
    NUM
FROM (
    SELECT
        H.HACKER_ID,
        H.NAME,
        C.NUM,
        MAX(C.NUM) OVER () AS NUM_MAX,
        COUNT(C.NUM) OVER (PARTITION BY C.NUM) AS NUM_CNT
    FROM HACKERS AS H
    JOIN (
        SELECT
            HACKER_ID,
            COUNT(CHALLENGE_ID) AS NUM
        FROM CHALLENGES
        GROUP BY 1
    ) AS C
    ON H.HACKER_ID = C.HACKER_ID
) SUB
WHERE NUM = NUM_MAX
OR NUM_CNT = 1
ORDER BY 3 DESC, 1
```

### 50. Contest Leaderboard
```SQL
SELECT
    H.HACKER_ID,
    H.NAME,
    S.TOTAL_SCORE
FROM HACKERS AS H
JOIN (
    SELECT
        SUB.HACKER_ID,
        SUM(SUB.SCORE) AS TOTAL_SCORE
    FROM (
        SELECT
            HACKER_ID,
            CHALLENGE_ID,
            MAX(SCORE) AS SCORE
        FROM SUBMISSIONS
        GROUP BY 1, 2
    ) SUB
    GROUP BY 1
) AS S
ON H.HACKER_ID = S.HACKER_ID
WHERE S.TOTAL_SCORE <> 0
ORDER BY 3 DESC, 1
```

### 51. SQL Project Planning
* 方法 1
```SQL
SELECT
    MIN(START_DATE),
    MAX(END_DATE)
FROM(
    SELECT
        START_DATE,
        END_DATE,
        ROW_NUMBER() OVER (ORDER BY END_DATE) AS NUM
    FROM PROJECTS
) SUB
GROUP BY DATE_SUB(END_DATE, INTERVAL NUM DAY)
ORDER BY DATEDIFF(MAX(END_DATE), MIN(START_DATE)) ASC, MIN(START_DATE) ASC
```
* 方法 2
```SQL
SELECT
    START_DATE,
    END_DATE
FROM (
    SELECT
        MIN(START_DATE) AS START_DATE,
        MAX(END_DATE) AS END_DATE,
        MAX(END_DATE) - MIN(START_DATE) + 1 AS TOTAL_DAYS
    FROM (
        SELECT
            START_DATE,
            END_DATE,
            DATE_SUB(END_DATE, INTERVAL ROW_NUM DAY) AS BEGIN_DATE
        FROM (
                SELECT
                ROW_NUMBER() OVER (ORDER BY START_DATE) AS ROW_NUM,
                START_DATE,
                END_DATE
            FROM PROJECTS
        ) SUB

    ) SUB2
    GROUP BY BEGIN_DATE
) SUB3
ORDER BY TOTAL_DAYS, START_DATE
```

### 52. Placements
* 方法 1
```SQL
SELECT
    SUB1.NAME
FROM (
    SELECT
        S.ID,
        S.NAME,
        P.SALARY
    FROM STUDENTS AS S
    JOIN PACKAGES AS P
    ON S.ID = P.ID
) SUB1
JOIN FRIENDS AS SUB2
ON SUB2.ID = SUB1.ID
JOIN (
    SELECT
        F.FRIEND_ID,
        P2.SALARY
    FROM FRIENDS AS F
    JOIN PACKAGES AS P2
    ON F.FRIEND_ID = P2.ID
) SUB3
ON SUB3.FRIEND_ID = SUB2.FRIEND_ID
WHERE SUB3.SALARY > SUB1.SALARY
ORDER BY SUB3.SALARY
```
* 方法 2
```SQL
SELECT
    S.NAME
FROM STUDENTS S
JOIN PACKAGES P1
ON S.ID = P1.ID
JOIN FRIENDS F
ON S.ID = F.ID
JOIN PACKAGES P2
ON F.FRIEND_ID = P2.ID
WHERE P2.SALARY > P1.SALARY
ORDER BY P2.SALARY
```

### 53. Symmetric Pairs
* 方法 1.
```SQL
SELECT
    DISTINCT T1.X, T1.Y
FROM (
    SELECT
        X,
        Y,
        ROW_NUMBER() OVER (ORDER BY X) AS NUM
    FROM FUNCTIONS
) AS T1
JOIN (
    SELECT
        X,
        Y,
        ROW_NUMBER() OVER (ORDER BY X) AS NUM
    FROM FUNCTIONS
) AS T2
ON T1.X = T2.Y AND T1.Y = T2.X AND T1.NUM <> T2.NUM
WHERE T1.X <= T1.Y
ORDER BY T1.X
```
* 方法 2.
```SQL
WITH T AS (
    SELECT
        DISTINCT X, Y,
        ROW_NUMBER() OVER (ORDER BY X) AS 'ROW_NUM'
    FROM FUNCTIONS
)
SELECT
    DISTINCT F1.X, F1.Y
FROM T F1
JOIN T F2
WHERE F1.X = F2.Y
AND F1.Y = F2.X
AND F1.ROW_NUM <> F2.ROW_NUM
AND F1.X <= F1.Y
ORDER BY F1.X
```

### 54. Interviews
```SQL
SELECT
    CONTESTS.CONTEST_ID,
    CONTESTS.HACKER_ID,
    CONTESTS.NAME,
    SUM(TOTAL_SUBMISSIONS),
    SUM(TOTAL_ACCEPTED_SUBMISSIONS),
    SUM(TOTAL_VIEWS),
    SUM(TOTAL_UNIQUE_VIEWS)
FROM CONTESTS
JOIN COLLEGES
ON CONTESTS.CONTEST_ID = COLLEGES.CONTEST_ID
JOIN CHALLENGES
ON COLLEGES.COLLEGE_ID = CHALLENGES.COLLEGE_ID
LEFT JOIN (
    SELECT
        CHALLENGE_ID,
        SUM(TOTAL_VIEWS) AS TOTAL_VIEWS,
        SUM(TOTAL_UNIQUE_VIEWS) AS TOTAL_UNIQUE_VIEWS
    FROM VIEW_STATS
    GROUP BY 1
) SUB1
ON CHALLENGES.CHALLENGE_ID = SUB1.CHALLENGE_ID
LEFT JOIN (
    SELECT
        CHALLENGE_ID,
        SUM(TOTAL_SUBMISSIONS) AS TOTAL_SUBMISSIONS,
        SUM(TOTAL_ACCEPTED_SUBMISSIONS) AS TOTAL_ACCEPTED_SUBMISSIONS
    FROM SUBMISSION_STATS
    GROUP BY 1
) SUB2
ON CHALLENGES.CHALLENGE_ID = SUB2.CHALLENGE_ID
GROUP BY 1, 2, 3
HAVING SUM(TOTAL_SUBMISSIONS) + SUM(TOTAL_ACCEPTED_SUBMISSIONS) + SUM(TOTAL_VIEWS) + SUM(TOTAL_UNIQUE_VIEWS) <> 0
```
```SQL
SELECT
    CONTESTS.CONTEST_ID,
    CONTESTS.HACKER_ID,
    CONTESTS.NAME,
    SUM(SUB2.TOTAL_SUBMISSIONS),
    SUM(SUB2.TOTAL_ACCEPTED_SUBMISSIONS),
    SUM(SUB1.TOTAL_VIEWS),
    SUM(SUB1.TOTAL_UNIQUE_VIEWS)
FROM CONTESTS
JOIN COLLEGES
ON CONTESTS.CONTEST_ID = COLLEGES.CONTEST_ID
JOIN CHALLENGES
ON COLLEGES.COLLEGE_ID = CHALLENGES.COLLEGE_ID
LEFT JOIN (
    SELECT
        CHALLENGE_ID,
        SUM(TOTAL_VIEWS) AS TOTAL_VIEWS,
        SUM(TOTAL_UNIQUE_VIEWS) AS TOTAL_UNIQUE_VIEWS
    FROM VIEW_STATS
    GROUP BY 1
) SUB1
ON CHALLENGES.CHALLENGE_ID = SUB1.CHALLENGE_ID
LEFT JOIN (
    SELECT
        CHALLENGE_ID,
        SUM(TOTAL_SUBMISSIONS) AS TOTAL_SUBMISSIONS,
        SUM(TOTAL_ACCEPTED_SUBMISSIONS) AS TOTAL_ACCEPTED_SUBMISSIONS
    FROM SUBMISSION_STATS
    GROUP BY 1
) SUB2
ON CHALLENGES.CHALLENGE_ID = SUB2.CHALLENGE_ID
GROUP BY 1, 2, 3
ORDER BY 1
```
```SQL
/*
Enter your query here.
*/
SELECT
    SUB.CONTEST_ID,
    SUB.HACKER_ID,
    SUB.NAME,
    SUM(SUM_TOTAL_SUBMISSIONS),
    SUM(SUM_TOTAL_ACCEPTED_SUBMISSIONS),
    SUM(SUM_TOTAL_VIEWS),
    SUM(SUM_TOTAL_UNIQUE_VIEWS)
FROM (
    SELECT
        C1.CONTEST_ID,
        C1.HACKER_ID,
        C1.NAME,
        C3.CHALLENGE_ID
    FROM CONTESTS C1, COLLEGES C2, CHALLENGES C3
    WHERE C1.CONTEST_ID = C2.CONTEST_ID
    AND C2.COLLEGE_ID = C3.COLLEGE_ID
) SUB
LEFT JOIN (
    SELECT
        CHALLENGE_ID,
        SUM(TOTAL_VIEWS) AS SUM_TOTAL_VIEWS,
        SUM(TOTAL_UNIQUE_VIEWS) AS SUM_TOTAL_UNIQUE_VIEWS
    FROM VIEW_STATS
    GROUP BY 1
) AS V
ON SUB.CHALLENGE_ID = V.CHALLENGE_ID
LEFT JOIN (
    SELECT
        CHALLENGE_ID,
        SUM(TOTAL_SUBMISSIONS) AS SUM_TOTAL_SUBMISSIONS,
        SUM(TOTAL_ACCEPTED_SUBMISSIONS) AS SUM_TOTAL_ACCEPTED_SUBMISSIONS
    FROM SUBMISSION_STATS
    GROUP BY 1
) AS S
ON SUB.CHALLENGE_ID = S.CHALLENGE_ID
GROUP BY 1, 2, 3
HAVING SUM(SUM_TOTAL_SUBMISSIONS) + SUM(SUM_TOTAL_ACCEPTED_SUBMISSIONS) + SUM(SUM_TOTAL_VIEWS) + SUM(SUM_TOTAL_UNIQUE_VIEWS) <> 0

```


### 55. 15 Days of Learning SQL (難)
```SQL
```

### 56.
```SQL
```

### 57.
```SQL
```

### 58.
```SQL
```

### 59.
```SQL
```

### 60.
```SQL
```
